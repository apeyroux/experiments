Talk title:
The Rent Is Too Damn High! Succinct Data Structures to the Rescue!!

Abstract for your talk:

In this era of bountiful disk space and unlimited cloud storage, it seems
ridiculous to claim that data takes up too much of it. But it does!

In this talk, I'll introduce succinct data structures, which are a way of
compressing data while still allowing useful queries to be run on it. I'll use
them to tackle an interview question and highlight how they are used in
practice for both fun and profit.

Timeline for your talk:

2 min: Linked lists take up too much space!
  - Assuming 64-bit values and pointers, each node takes 64 bits to store a
    value and 64 more bits to store the address of the next node!
  - Effectively a 2x space increase
  - "Silly me, nobody does that! We use contiguous arrays instead!"
2 min: Contiguous arrays take up too much space!
  - Suppose you have an array of 1 million phone numbers between 0 and
    999,999,999
  - Storing it costs 10^6*32 ~=32MB, then you have to sort it, carry it around..
3 min: Or...
  - Represent each number as a set bit on a giant bit array
  - Storing it costs 10^6 ~= 1MB (!)
  - Bonus: data is already sorted!
  - Checking membership: bitwise and!
  - Rank(i): number of set bits up to index i (number of prior phone numbers)
  - Select(i): index of the ith set bit (what is the ith phone number?)
  - Can perform these operations in O(1) time!
1 min: Representing Trees
  - Original purpose of succinct data structures
  - The bulk of a tree's space usage is pointers to nodes
  - Represent the tree structure as balanced parentheses
  - Can be stored as a bit array: '(' -> 1, ')' -> 0
2 min: applications in industry
  - Indexing structured data to prevent unnecessary re-parsing: semi-indexing
    structured data in tiny space, https://github.com/haskell-works/hw-json
  - TerarkDB: storage improvements based on Succinct Nested Tries

Intended audience:
Anyone interested in saving space and fun data structures. Bit-twiddling
familiarity appreciated but not required.
